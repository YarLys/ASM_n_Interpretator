# Домашнее задание 4 по конфигурационному управлению
## Лысаков Ярослав, ИКБО-50-23
## Этапы запуска проекта репозитория
1. Загрузить репозиторий на компьютер 'git clone https://github.com/YarLys/ASM_n_Interpretator'
2. Перейти в директорию проекта 'cd ASM_n_Interpretator'
3. Написать программу в файл 'program.txt' или любой другой
4. В случае использования Ассемблера выполнить следующую команду 'python asm.py <Файл с исходным кодом программы> <Файл, в который будет записан бинарный код> <Файл для логирования>'
5. В случае использования Интерпретатора выполнить следующую команду 'python interpretator.py <Файл с бинарным кодом> <Выходной файл для записи> <Начало диапазона памяти для выходного файла> <Конец диапазона>'

## Описание задания
Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ). Система команд УВМ представлена далее. 
Для ассемблера необходимо разработать читаемое представление команд УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к которой задается из командной строки. Результатом работы ассемблера является бинарный файл в виде последовательности байт, путь к которому задается из командной строки. Дополнительный ключ командной строки задает путь к файлулогу, в котором хранятся ассемблированные инструкции в духе списков “ключ=значение”, как в приведенных далее тестах.
Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон также указывается из командной строки.
Форматом для файла-лога и файла-результата является xml.

## Описание команд
### Загрузка константы
|A|B|
|-|-|
|Биты 0-6|Биты 7-29|
|104|Константа|

Размер команды: 4 байт. Операнд: поле B. Результат: новый элемент на стеке.
Тест (A=104, B=920):
Байт-код: 0x68, 0xCC, 0x01, 0x00

### Чтение значения из памяти
|A|B|
|-|-|
|Биты 0-6|Биты 7-27|
|45|Адрес|

Размер команды: 4 байт. Операнд: значение в памяти по адресу, которым является поле B. Результат: новый элемент на стеке.
Тест (A=45, B=255):
Байт-код: 0xAD, 0x7F, 0x00, 0x00

### Запись значения в память
|A|
|-|
|Биты 0-6|
|8|

Размер команды: 4 байт. Операнд: элемент, снятый с вершины стека.
Результат: значение в памяти по адресу, которым является элемент, снятый с вершины стека.
Тест (A=8):
Байт-код: 0x08, 0x00, 0x00, 0x00

### Бинарная операция: сложение
|A|B|
|-|-|
|Биты 0-6|Биты 7-18|
|91|Смещение|

Размер команды: 4 байт. Первый операнд: значение в памяти по адресу, которым является сумма адреса (элемент, снятый с вершины стека) и смещения (поле B). Второй операнд: элемент, снятый с вершины стека. Результат: новый элемент на стеке.
Тест (A=91, B=339):
Байт-код: 0xDB, 0xA9, 0x00, 0x00

## Реализованные функции
### Класс Assembler, содержащий нижеперечисленные функции
#### __init__():
Инициализация класса.
#### load_const(x):
Проверяет размер x, формирует бинарный код и код для лог-файла.
#### read_mem(x):
Проверяет размер x, аналогично формирует бинарный код и код для лог-файла.
#### write_mem():
Формирует бинарный код и код для лог-файла.
#### add(x):
Проверяет размер x, аналогично формирует бинарный код и код для лог-файла.
#### write():
Записывает сформированные значения в бинарный файл и в файл логов.
#### assembly():
Читает входной файл, построчно анализирует команды, обрабатывает ошибки, вызывает соответствующие функции.
#### main():
Получает ключи, заданные в командной строке, запускает работу ассемблера.

### Класс Interpretator, содержащий нижеперечисленные функции
#### __init__():
Инициализация класса.
#### read_file():
Считывает бинарный файл, преобразует считанные байты в команды размером по 4 байта.
#### get_low_bits(command, n):
Возвращает n младших битов команды.
#### get_high_bits(command, n):
Возвращает старшие биты команды, начиная с номера n.
#### interpret():
Проходится по командам, в соответствии с кодом осуществляет моделирование выполнения команды. Также обрабатывает ошибки.
#### write_output():
Записывает информацию в выходной файл.
#### main():
Получает ключи, заданные в командной строке, запускает работу интерпретатора.

## Пример работы программы
Тестовая программа: Выполнить поэлементно операцию сложение над двумя векторами длины 4. Результат записать во второй вектор.
Файл с исходным кодом:
```
LOAD_CONST 5
LOAD_CONST 100
LOAD_CONST 10
LOAD_CONST 1
LOAD_CONST 17
LOAD_CONST 8
LOAD_CONST 21
LOAD_CONST 12
WRITE_MEM
WRITE_MEM
WRITE_MEM
WRITE_MEM
WRITE_MEM
WRITE_MEM
WRITE_MEM
WRITE_MEM
LOAD_CONST 5
LOAD_CONST 100
ADD 0
LOAD_CONST 10
LOAD_CONST 1
ADD 0
LOAD_CONST 17
LOAD_CONST 8
ADD 0
LOAD_CONST 21
LOAD_CONST 12
ADD 0
```

Выходной xml файл:
```
<?xml version="1.0" encoding="UTF-8"?>
<output>
	<MEMORY ADDR=1>1</MEMORY>
	<MEMORY ADDR=5>5</MEMORY>
	<MEMORY ADDR=8>8</MEMORY>
	<MEMORY ADDR=10>10</MEMORY>
	<MEMORY ADDR=12>12</MEMORY>
	<MEMORY ADDR=17>17</MEMORY>
	<MEMORY ADDR=21>21</MEMORY>
	<MEMORY ADDR=100>100</MEMORY>
</output
```

## Результаты тестирования
![image](https://github.com/user-attachments/assets/47c28ef5-cf51-4fda-b33b-78edb3bf90e1)
![image](https://github.com/user-attachments/assets/92e00bb4-d5b0-4bfe-bcbd-85ff3debc7be)
![image](https://github.com/user-attachments/assets/e9f58c62-32b3-4487-b3dd-26ee10704a72)
![image](https://github.com/user-attachments/assets/9c33ea6c-6cfc-4450-921c-1defb87e3855)




